<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.docker/php/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.docker/php/Dockerfile" />
              <option name="originalContent" value="FROM php:8.4-fpm-alpine&#10;&#10;# Install system dependencies&#10;RUN apk add --no-cache \&#10;    postgresql-dev \&#10;    libzip-dev \&#10;    zip \&#10;    unzip \&#10;    git \&#10;    linux-headers \&#10;    autoconf \&#10;    gcc \&#10;    g++ \&#10;    make&#10;&#10;# Install PHP extensions&#10;RUN docker-php-ext-install pdo pdo_pgsql zip pcntl&#10;&#10;# Install Swoole&#10;RUN apk add --no-cache $PHPIZE_DEPS \&#10;    &amp;&amp; pecl install swoole-5.0.3 \&#10;    &amp;&amp; rm -rf /tmp/* \&#10;    &amp;&amp; rm -rf /tmp/* \&#10;    &amp;&amp; apk del $PHPIZE_DEPS&#10;&#10;# Configure PHP&#10;RUN mv &quot;$PHP_INI_DIR/php.ini-production&quot; &quot;$PHP_INI_DIR/php.ini&quot;&#10;&#10;# Install Composer&#10;COPY --from=composer:latest /usr/bin/composer /usr/bin/composer&#10;&#10;WORKDIR /var/www/html&#10;&#10;# Copy start script and make it executable&#10;COPY start-app.sh /usr/local/bin/start-app&#10;RUN chmod +x /usr/local/bin/start-app&#10;&#10;CMD [&quot;/usr/local/bin/start-app&quot;]&#10;" />
              <option name="updatedContent" value="FROM php:8.4-fpm-alpine&#10;&#10;# Install system dependencies (including build deps required by Swoole)&#10;RUN apk add --no-cache \&#10;    postgresql-dev \&#10;    libzip-dev \&#10;    zlib-dev \&#10;    openssl-dev \&#10;    zip \&#10;    unzip \&#10;    git \&#10;    linux-headers \&#10;    build-base \&#10;    autoconf&#10;&#10;# Install PHP extensions&#10;RUN docker-php-ext-install pdo pdo_pgsql zip pcntl&#10;&#10;# Install Swoole (let pecl pick a compatible release for the PHP version)&#10;RUN apk add --no-cache --virtual .build-deps $PHPIZE_DEPS openssl-dev zlib-dev brotli-dev \&#10;    &amp;&amp; pecl channel-update pecl.php.net \&#10;    &amp;&amp; pecl install -f swoole \&#10;    &amp;&amp; docker-php-ext-enable swoole \&#10;    &amp;&amp; printf &quot;extension=swoole.so\n&quot; &gt; &quot;$PHP_INI_DIR/conf.d/docker-php-ext-swoole.ini&quot; \&#10;    &amp;&amp; rm -rf /tmp/pear /tmp/* \&#10;    &amp;&amp; apk del .build-deps&#10;&#10;# Configure PHP&#10;RUN mv &quot;$PHP_INI_DIR/php.ini-production&quot; &quot;$PHP_INI_DIR/php.ini&quot;&#10;&#10;# Install Composer&#10;COPY --from=composer:latest /usr/bin/composer /usr/bin/composer&#10;&#10;WORKDIR /var/www/html&#10;&#10;# Copy start script and make it executable&#10;COPY start-app.sh /usr/local/bin/start-app&#10;RUN chmod +x /usr/local/bin/start-app&#10;&#10;CMD [&quot;/usr/local/bin/start-app&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bootstrap.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bootstrap.sh" />
              <option name="originalContent" value="#!/usr/bin/env bash&#10;set -euo pipefail&#10;&#10;VERSION=&quot;2.5.0&quot;&#10;RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'&#10;BLUE='\033[0;34m'; CYAN='\033[0;36m'; NC='\033[0m'&#10;&#10;PROJECT_NAME=&quot;&quot;; FRAMEWORK=&quot;&quot;; SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;&#10;PROGRESS_TOTAL=55; PROGRESS_CURRENT=0&#10;&#10;log_info() { echo -e &quot;${BLUE}ℹ️  $1${NC}&quot;; }&#10;log_success() { echo -e &quot;${GREEN}✅ $1${NC}&quot;; }&#10;log_warning() { echo -e &quot;${YELLOW}⚠️  $1${NC}&quot;; }&#10;log_error() { echo -e &quot;${RED}❌ $1${NC}&quot;; }&#10;log_step() { echo -e &quot;${CYAN} $1${NC}&quot;; }&#10;increment_progress() { PROGRESS_CURRENT=$((PROGRESS_CURRENT + 1)); show_progress; }&#10;&#10;show_progress() {&#10;    local width=62&#10;    local completed=$((PROGRESS_CURRENT * width / PROGRESS_TOTAL))&#10;    local remaining=$((width - completed))&#10;    tput sc&#10;    tput cup 4 0&#10;    printf &quot;${CYAN}[&quot;&#10;    printf &quot;%${completed}s&quot; | tr ' ' '█'&#10;    printf &quot;%${remaining}s&quot; | tr ' ' '░'&#10;    printf &quot;] %d%%${NC}&quot; $((PROGRESS_CURRENT * 100 / PROGRESS_TOTAL))&#10;    tput rc&#10;}&#10;&#10;render_header() {&#10;    clear&#10;    echo -e &quot;${BLUE}╔══════════════════════════════════════════════════════════════╗${NC}&quot;&#10;    echo -e &quot;${BLUE}║                     Canvas PHP v${VERSION}                      ║${NC}&quot;&#10;    echo -e &quot;${BLUE}║            Criador de Projetos Profissionais                 ║${NC}&quot;&#10;    echo -e &quot;${BLUE}╚══════════════════════════════════════════════════════════════╝${NC}&quot;&#10;    echo -e &quot;\n&quot;&#10;    echo&#10;    show_progress&#10;}&#10;&#10;check_dependencies() {&#10;    for dep in git docker docker-compose nc; do&#10;        command -v &quot;$dep&quot; &gt;/dev/null 2&gt;&amp;1 || { log_error &quot;$dep não encontrado&quot;; exit 1; }&#10;    done&#10;}&#10;&#10;select_framework() {&#10;    render_header&#10;    read -rp &quot; Nome do projeto (pasta destino): &quot; PROJECT_NAME&#10;    [ -z &quot;$PROJECT_NAME&quot; ] &amp;&amp; log_error &quot;Nome do projeto não pode ser vazio&quot; &amp;&amp; exit 1&#10;&#10;    local options=(&quot;Laravel&quot; &quot;Hyperf&quot;); local selected=0; tput civis&#10;    while true; do&#10;        render_header&#10;        echo &quot;Escolha o framework para o projeto:&quot;&#10;        for i in &quot;${!options[@]}&quot;; do&#10;            if [[ &quot;$i&quot; -eq &quot;$selected&quot; ]]; then echo -e &quot; &gt; ${GREEN}${options[i]}${NC}&quot;; else echo &quot;   ${options[i]}&quot;; fi&#10;        done&#10;        IFS= read -rsn1 key&#10;        if [[ $key == &quot;&quot; ]]; then break; fi&#10;        if [[ $key == $'\x1b' ]]; then IFS= read -rsn2 key2&#10;            case &quot;$key2&quot; in '[A') selected=$(( (selected - 1 + ${#options[@]}) % ${#options[@]} )) ;; '[B') selected=$(( (selected + 1) % ${#options[@]} )) ;; esac&#10;        fi&#10;    done&#10;    tput cnorm&#10;    FRAMEWORK=&quot;${options[$selected],,}&quot;; increment_progress&#10;    echo &quot;DEBUG: FRAMEWORK selecionado = $FRAMEWORK&quot;&#10;}&#10;&#10;create_essential_files() {&#10;    # Create directory structure&#10;    mkdir -p &quot;$PROJECT_NAME&quot;/.docker/{php,nginx}&#10;&#10;    # Create essential configuration files&#10;    cat &gt; &quot;$PROJECT_NAME/.env&quot; &lt;&lt; EOF&#10;PROJECT_NAME=$PROJECT_NAME&#10;DB_DATABASE=${PROJECT_NAME}_db&#10;DB_USERNAME=user&#10;DB_PASSWORD=secret&#10;EOF&#10;&#10;    # Create empty directories with proper permissions&#10;    mkdir -p &quot;$PROJECT_NAME&quot;/{storage,bootstrap/cache}&#10;    chmod -R 775 &quot;$PROJECT_NAME&quot;/storage &quot;$PROJECT_NAME&quot;/bootstrap/cache 2&gt;/dev/null || true&#10;&#10;    # Copy Docker configuration files&#10;    cp -f &quot;$SCRIPT_DIR/.docker/php/Dockerfile&quot; &quot;$PROJECT_NAME/.docker/php/&quot;&#10;    cp -f &quot;$SCRIPT_DIR/.docker/php/php.ini&quot; &quot;$PROJECT_NAME/.docker/php/&quot;&#10;    cp -f &quot;$SCRIPT_DIR/.docker/php/start-app.sh&quot; &quot;$PROJECT_NAME/.docker/php/&quot;&#10;    chmod +x &quot;$PROJECT_NAME/.docker/php/start-app.sh&quot;&#10;    cp -f &quot;$SCRIPT_DIR/.docker/nginx/default.conf&quot; &quot;$PROJECT_NAME/.docker/nginx/&quot;&#10;&#10;    # docker-compose.yml with updated configuration&#10;    cat &gt; &quot;$PROJECT_NAME/docker-compose.yml&quot; &lt;&lt; EOF&#10;services:&#10;  app:&#10;    build: ./.docker/php&#10;    container_name: ${PROJECT_NAME}_php&#10;    working_dir: /var/www/html&#10;    volumes:&#10;      - ./:/var/www/html&#10;    environment:&#10;      PHP_IDE_CONFIG: &quot;serverName=app&quot;&#10;      DB_CONNECTION: pgsql&#10;      DB_HOST: postgres&#10;      DB_PORT: 5432&#10;      DB_DATABASE: ${PROJECT_NAME}_db&#10;      DB_USERNAME: user&#10;      DB_PASSWORD: secret&#10;      REDIS_HOST: redis&#10;      REDIS_PORT: 6379&#10;    depends_on:&#10;      postgres:&#10;        condition: service_healthy&#10;      redis:&#10;        condition: service_started&#10;    networks:&#10;      - ${PROJECT_NAME}_net&#10;&#10;  nginx:&#10;    image: nginx:1.25-alpine&#10;    container_name: ${PROJECT_NAME}_nginx&#10;    volumes:&#10;      - ./:/var/www/html&#10;      - ./.docker/nginx/default.conf:/etc/nginx/conf.d/default.conf&#10;    ports:&#10;      - &quot;8080:80&quot;&#10;    depends_on:&#10;      - app&#10;    networks:&#10;      - ${PROJECT_NAME}_net&#10;&#10;  postgres:&#10;    image: postgres:15-alpine&#10;    container_name: ${PROJECT_NAME}_postgres&#10;    environment:&#10;      POSTGRES_DB: ${PROJECT_NAME}_db&#10;      POSTGRES_USER: user&#10;      POSTGRES_PASSWORD: secret&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;    healthcheck:&#10;      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U user -d ${PROJECT_NAME}_db&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 5&#10;    networks:&#10;      - ${PROJECT_NAME}_net&#10;&#10;  redis:&#10;    image: redis:7-alpine&#10;    container_name: ${PROJECT_NAME}_redis&#10;    networks:&#10;      - ${PROJECT_NAME}_net&#10;&#10;networks:&#10;  ${PROJECT_NAME}_net:&#10;    driver: bridge&#10;&#10;volumes:&#10;  postgres_data:&#10;EOF&#10;&#10;    increment_progress&#10;    log_success &quot;Arquivos essenciais criados&quot;&#10;}&#10;&#10;initialize_containers() {&#10;#    cd &quot;$PROJECT_NAME&quot; || { log_error &quot;Não foi possível entrar no diretório $PROJECT_NAME&quot;; exit 1; }&#10;&#10;    log_step &quot;Parando containers anteriores (se existirem)...&quot;&#10;    docker-compose down --remove-orphans --volumes 2&gt;/dev/null || true&#10;&#10;    log_step &quot;Construindo containers (tentar docker compose build)...&quot;&#10;&#10;    # Try docker compose build first. If it fails with a bake error, fall back to docker build for the php image.&#10;    if docker-compose build --no-cache app; then&#10;        log_success &quot;docker-compose build concluído com sucesso&quot;&#10;        BUILD_FALLBACK=false&#10;    else&#10;        log_warning &quot;docker-compose build falhou — tentando fallback com docker build&quot;&#10;        BUILD_FALLBACK=true&#10;    fi&#10;&#10;    if [ &quot;$BUILD_FALLBACK&quot; = true ]; then&#10;        # Build the php image directly and then bring up the stack without building&#10;        PHP_IMAGE_TAG=&quot;${PROJECT_NAME}_php&quot;&#10;        log_step &quot;Construindo imagem php diretamente: ${PHP_IMAGE_TAG}&quot;&#10;        if docker build -t &quot;${PHP_IMAGE_TAG}&quot; ./.docker/php; then&#10;            log_success &quot;Imagem php construída: ${PHP_IMAGE_TAG}&quot;&#10;        else&#10;            log_error &quot;Falha ao construir a imagem php diretamente&quot;&#10;            exit 1&#10;        fi&#10;&#10;        log_step &quot;Iniciando containers (sem rebuild)...&quot;&#10;        docker-compose up -d --no-build&#10;    else&#10;        log_step &quot;Iniciando containers...&quot;&#10;        docker-compose up -d&#10;    fi&#10;&#10;    # Wait for containers to be ready&#10;    log_step &quot;Aguardando containers iniciarem...&quot;&#10;    local max_attempts=30&#10;    local attempt=0&#10;    while ! docker-compose ps app | grep -q &quot;Up&quot; &amp;&amp; [ $attempt -lt $max_attempts ]; do&#10;        echo -n &quot;.&quot;&#10;        sleep 2&#10;        attempt=$((attempt + 1))&#10;    done&#10;    echo &quot;&quot;&#10;&#10;    if [ $attempt -eq $max_attempts ]; then&#10;        log_error &quot;Timeout aguardando containers iniciarem&quot;&#10;        docker-compose logs app || true&#10;        exit 1&#10;    fi&#10;&#10;    # Wait for postgres to be healthy&#10;    log_step &quot;Aguardando banco de dados...&quot;&#10;    attempt=0&#10;    while ! docker-compose exec -T postgres pg_isready -U user -d &quot;${PROJECT_NAME}_db&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; [ $attempt -lt $max_attempts ]; do&#10;        echo -n &quot;.&quot;&#10;        sleep 2&#10;        attempt=$((attempt + 1))&#10;    done&#10;    echo &quot;&quot;&#10;&#10;    if [ $attempt -eq $max_attempts ]; then&#10;        log_error &quot;Timeout aguardando banco de dados&quot;&#10;        docker-compose logs postgres || true&#10;        exit 1&#10;    fi&#10;&#10;    # Give extra time for services to fully initialize&#10;    sleep 5&#10;    increment_progress&#10;}&#10;&#10;create_framework() {&#10;    cd &quot;$PROJECT_NAME&quot;&#10;    TMP_FRAMEWORK=&quot;.canvas_tmp_framework&quot;&#10;    mkdir -p &quot;$TMP_FRAMEWORK&quot;&#10;&#10;    log_step &quot;Criando framework $FRAMEWORK...&quot;&#10;    if [ &quot;$FRAMEWORK&quot; = &quot;Laravel&quot; ]; then&#10;        # 1️⃣ Criar Laravel na pasta temporária&#10;        docker run --rm -v &quot;$(pwd)/$TMP_FRAMEWORK&quot;:/var/www/html -w /var/www/html composer create-project laravel/laravel . --no-interaction&#10;&#10;        # 2️⃣ Instalar Octane + Swoole **antes do merge**&#10;        docker run --rm -v &quot;$(pwd)/$TMP_FRAMEWORK&quot;:/var/www/html -w /var/www/html composer require laravel/octane --no-interaction&#10;    else&#10;        # Hyperf&#10;        docker build -t canvas-php-hyperf-temp -f .docker/php/Dockerfile-hyperf .&#10;        docker run --rm -v &quot;$(pwd)/$TMP_FRAMEWORK&quot;:/var/www/html -w /var/www/html canvas-php-hyperf-temp composer create-project hyperf/hyperf-skeleton . --no-interaction&#10;    fi&#10;    increment_progress&#10;&#10;    # 3️⃣ Remover diretórios antigos do host&#10;    dirs_to_remove=(app bootstrap config database public resources routes storage tests vendor)&#10;    for dir in &quot;${dirs_to_remove[@]}&quot;; do [ -d &quot;$dir&quot; ] &amp;&amp; rm -rf &quot;$dir&quot;; done&#10;&#10;    # 4️⃣ Mover framework para pasta do host&#10;    shopt -s dotglob&#10;    mv &quot;$TMP_FRAMEWORK&quot;/* .&#10;    rm -rf &quot;$TMP_FRAMEWORK&quot;&#10;    shopt -u dotglob&#10;    increment_progress&#10;    log_success &quot;Framework movido e merge concluído&quot;&#10;}&#10;&#10;setup_laravel() {&#10;    if [ &quot;$FRAMEWORK&quot; = &quot;Laravel&quot; ]; then&#10;        log_step &quot;Configurando Laravel Octane...&quot;&#10;&#10;        # Fix permissions&#10;        docker-compose exec -T app chown -R www-data:www-data /var/www/html/storage /var/www/html/bootstrap/cache&#10;        docker-compose exec -T app chmod -R 775 /var/www/html/storage /var/www/html/bootstrap/cache&#10;&#10;        # Generate application key&#10;        docker-compose exec -T app php artisan key:generate&#10;&#10;        # Install and configure Octane&#10;        docker-compose exec -T app composer require laravel/octane&#10;        docker-compose exec -T app php artisan octane:install --server=swoole --no-interaction&#10;&#10;        # Run Laravel optimizations&#10;        docker-compose exec -T app php artisan config:cache&#10;        docker-compose exec -T app php artisan route:cache&#10;        docker-compose exec -T app php artisan view:cache&#10;&#10;        # Restart the container to apply Octane&#10;        docker-compose restart app&#10;&#10;        increment_progress&#10;        log_success &quot;Laravel Octane + Swoole configurado com sucesso&quot;&#10;    fi&#10;}&#10;&#10;main() {&#10;    check_dependencies&#10;&#10;    # Non-interactive support for CI or automated runs&#10;    if [ -n &quot;${CI_PROJECT_NAME:-}&quot; ] &amp;&amp; [ -n &quot;${CI_FRAMEWORK:-}&quot; ]; then&#10;        PROJECT_NAME=&quot;$CI_PROJECT_NAME&quot;&#10;        FRAMEWORK=&quot;$CI_FRAMEWORK&quot;&#10;        echo &quot;Non-interactive mode: PROJECT_NAME=$PROJECT_NAME, FRAMEWORK=$FRAMEWORK&quot;&#10;        increment_progress&#10;    else&#10;        select_framework&#10;    fi&#10;&#10;    create_essential_files&#10;    create_framework&#10;    initialize_containers&#10;    setup_laravel&#10;&#10;    PROGRESS_CURRENT=$PROGRESS_TOTAL&#10;    show_progress; echo&#10;    log_success &quot;Projeto $PROJECT_NAME criado com sucesso com o framework $FRAMEWORK!&quot;&#10;    echo &quot; Pasta do projeto: $(pwd)&quot;&#10;    echo &quot; App: http://localhost:8080&quot;&#10;    echo &quot; Postgres: localhost:5432 (db:${PROJECT_NAME}_db / user:user / pass:secret)&quot;&#10;    echo &quot; Redis: localhost:6379&quot;&#10;}&#10;&#10;main" />
              <option name="updatedContent" value="#!/usr/bin/env bash&#10;set -euo pipefail&#10;&#10;VERSION=&quot;2.5.0&quot;&#10;RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'&#10;BLUE='\033[0;34m'; CYAN='\033[0;36m'; NC='\033[0m'&#10;&#10;PROJECT_NAME=&quot;&quot;; FRAMEWORK=&quot;&quot;; SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;&#10;PROGRESS_TOTAL=55; PROGRESS_CURRENT=0&#10;&#10;log_info() { echo -e &quot;${BLUE}ℹ️  $1${NC}&quot;; }&#10;log_success() { echo -e &quot;${GREEN}✅ $1${NC}&quot;; }&#10;log_warning() { echo -e &quot;${YELLOW}⚠️  $1${NC}&quot;; }&#10;log_error() { echo -e &quot;${RED}❌ $1${NC}&quot;; }&#10;log_step() { echo -e &quot;${CYAN} $1${NC}&quot;; }&#10;increment_progress() { PROGRESS_CURRENT=$((PROGRESS_CURRENT + 1)); show_progress; }&#10;&#10;show_progress() {&#10;    local width=62&#10;    local completed=$((PROGRESS_CURRENT * width / PROGRESS_TOTAL))&#10;    local remaining=$((width - completed))&#10;    tput sc&#10;    tput cup 4 0&#10;    printf &quot;${CYAN}[&quot;&#10;    printf &quot;%${completed}s&quot; | tr ' ' '█'&#10;    printf &quot;%${remaining}s&quot; | tr ' ' '░'&#10;    printf &quot;] %d%%${NC}&quot; $((PROGRESS_CURRENT * 100 / PROGRESS_TOTAL))&#10;    tput rc&#10;}&#10;&#10;render_header() {&#10;    clear&#10;    echo -e &quot;${BLUE}╔══════════════════════════════════════════════════════════════╗${NC}&quot;&#10;    echo -e &quot;${BLUE}║                     Canvas PHP v${VERSION}                      ║${NC}&quot;&#10;    echo -e &quot;${BLUE}║            Criador de Projetos Profissionais                 ║${NC}&quot;&#10;    echo -e &quot;${BLUE}╚══════════════════════════════════════════════════════════════╝${NC}&quot;&#10;    echo -e &quot;\n&quot;&#10;    echo&#10;    show_progress&#10;}&#10;&#10;check_dependencies() {&#10;    for dep in git docker docker-compose nc; do&#10;        command -v &quot;$dep&quot; &gt;/dev/null 2&gt;&amp;1 || { log_error &quot;$dep não encontrado&quot;; exit 1; }&#10;    done&#10;}&#10;&#10;select_framework() {&#10;    render_header&#10;    read -rp &quot; Nome do projeto (pasta destino): &quot; PROJECT_NAME&#10;    [ -z &quot;$PROJECT_NAME&quot; ] &amp;&amp; log_error &quot;Nome do projeto não pode ser vazio&quot; &amp;&amp; exit 1&#10;&#10;    local options=(&quot;Laravel&quot; &quot;Hyperf&quot;); local selected=0; tput civis&#10;    while true; do&#10;        render_header&#10;        echo &quot;Escolha o framework para o projeto:&quot;&#10;        for i in &quot;${!options[@]}&quot;; do&#10;            if [[ &quot;$i&quot; -eq &quot;$selected&quot; ]]; then echo -e &quot; &gt; ${GREEN}${options[i]}${NC}&quot;; else echo &quot;   ${options[i]}&quot;; fi&#10;        done&#10;        IFS= read -rsn1 key&#10;        if [[ $key == &quot;&quot; ]]; then break; fi&#10;        if [[ $key == $'\x1b' ]]; then IFS= read -rsn2 key2&#10;            case &quot;$key2&quot; in '[A') selected=$(( (selected - 1 + ${#options[@]}) % ${#options[@]} )) ;; '[B') selected=$(( (selected + 1) % ${#options[@]} )) ;; esac&#10;        fi&#10;    done&#10;    tput cnorm&#10;    FRAMEWORK=&quot;${options[$selected],,}&quot;; increment_progress&#10;    echo &quot;DEBUG: FRAMEWORK selecionado = $FRAMEWORK&quot;&#10;}&#10;&#10;create_essential_files() {&#10;    # Ensure project directory exists, use absolute PROJECT_DIR&#10;    mkdir -p &quot;$PROJECT_DIR&quot;/.docker/{php,nginx}&#10;&#10;    # Create essential configuration files&#10;    cat &gt; &quot;$PROJECT_DIR/.env&quot; &lt;&lt; EOF&#10;PROJECT_NAME=$PROJECT_NAME&#10;DB_DATABASE=${PROJECT_NAME}_db&#10;DB_USERNAME=user&#10;DB_PASSWORD=secret&#10;EOF&#10;&#10;    # Create empty directories with proper permissions&#10;    mkdir -p &quot;$PROJECT_DIR&quot;/{storage,bootstrap/cache}&#10;    chmod -R 775 &quot;$PROJECT_DIR&quot;/storage &quot;$PROJECT_DIR&quot;/bootstrap/cache 2&gt;/dev/null || true&#10;&#10;    # Copy Docker configuration files&#10;    cp -f &quot;$SCRIPT_DIR/.docker/php/Dockerfile&quot; &quot;$PROJECT_DIR/.docker/php/&quot;&#10;    cp -f &quot;$SCRIPT_DIR/.docker/php/php.ini&quot; &quot;$PROJECT_DIR/.docker/php/&quot;&#10;    cp -f &quot;$SCRIPT_DIR/.docker/php/start-app.sh&quot; &quot;$PROJECT_DIR/.docker/php/&quot;&#10;    chmod +x &quot;$PROJECT_DIR/.docker/php/start-app.sh&quot;&#10;    cp -f &quot;$SCRIPT_DIR/.docker/nginx/default.conf&quot; &quot;$PROJECT_DIR/.docker/nginx/&quot;&#10;&#10;    # docker-compose.yml with updated configuration&#10;    cat &gt; &quot;$PROJECT_DIR/docker-compose.yml&quot; &lt;&lt; EOF&#10;services:&#10;  app:&#10;    build: ./.docker/php&#10;    container_name: ${PROJECT_NAME}_php&#10;    working_dir: /var/www/html&#10;    volumes:&#10;      - ./:/var/www/html&#10;    environment:&#10;      PHP_IDE_CONFIG: &quot;serverName=app&quot;&#10;      DB_CONNECTION: pgsql&#10;      DB_HOST: postgres&#10;      DB_PORT: 5432&#10;      DB_DATABASE: ${PROJECT_NAME}_db&#10;      DB_USERNAME: user&#10;      DB_PASSWORD: secret&#10;      REDIS_HOST: redis&#10;      REDIS_PORT: 6379&#10;    depends_on:&#10;      postgres:&#10;        condition: service_healthy&#10;      redis:&#10;        condition: service_started&#10;    networks:&#10;      - ${PROJECT_NAME}_net&#10;&#10;  nginx:&#10;    image: nginx:1.25-alpine&#10;    container_name: ${PROJECT_NAME}_nginx&#10;    volumes:&#10;      - ./:/var/www/html&#10;      - ./.docker/nginx/default.conf:/etc/nginx/conf.d/default.conf&#10;    ports:&#10;      - &quot;8080:80&quot;&#10;    depends_on:&#10;      - app&#10;    networks:&#10;      - ${PROJECT_NAME}_net&#10;&#10;  postgres:&#10;    image: postgres:15-alpine&#10;    container_name: ${PROJECT_NAME}_postgres&#10;    environment:&#10;      POSTGRES_DB: ${PROJECT_NAME}_db&#10;      POSTGRES_USER: user&#10;      POSTGRES_PASSWORD: secret&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;    healthcheck:&#10;      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U user -d ${PROJECT_NAME}_db&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 5&#10;    networks:&#10;      - ${PROJECT_NAME}_net&#10;&#10;  redis:&#10;    image: redis:7-alpine&#10;    container_name: ${PROJECT_NAME}_redis&#10;    networks:&#10;      - ${PROJECT_NAME}_net&#10;&#10;  minio:&#10;    image: minio/minio&#10;    container_name: ${PROJECT_NAME}_minio&#10;    environment:&#10;      MINIO_ROOT_USER: minioadmin&#10;      MINIO_ROOT_PASSWORD: minioadmin&#10;    volumes:&#10;      - minio_data:/data&#10;    command: server /data&#10;    ports:&#10;      - &quot;9000:9000&quot;&#10;    networks:&#10;      - ${PROJECT_NAME}_net&#10;&#10;  mailpit:&#10;    image: mailhog/mailhog&#10;    container_name: ${PROJECT_NAME}_mailpit&#10;    ports:&#10;      - &quot;8025:8025&quot;&#10;    networks:&#10;      - ${PROJECT_NAME}_net&#10;&#10;networks:&#10;  ${PROJECT_NAME}_net:&#10;    driver: bridge&#10;&#10;volumes:&#10;  postgres_data:&#10;  minio_data:&#10;EOF&#10;&#10;    increment_progress&#10;    log_success &quot;Arquivos essenciais criados&quot;&#10;}&#10;&#10;initialize_containers() {&#10;    # Ensure docker-compose commands run inside the project directory&#10;    pushd &quot;$PROJECT_DIR&quot; &gt;/dev/null || { log_error &quot;Não foi possível entrar no diretório $PROJECT_DIR&quot;; exit 1; }&#10;&#10;    log_step &quot;Parando containers anteriores (se existirem)...&quot;&#10;    docker-compose down --remove-orphans --volumes 2&gt;/dev/null || true&#10;&#10;    log_step &quot;Construindo containers (tentar docker compose build)...&quot;&#10;&#10;    # Try docker compose build first. If it fails with a bake error, fall back to docker build for the php image.&#10;    if docker-compose build --no-cache app; then&#10;        log_success &quot;docker-compose build concluído com sucesso&quot;&#10;        BUILD_FALLBACK=false&#10;    else&#10;        log_warning &quot;docker-compose build falhou — tentando fallback com docker build&quot;&#10;        BUILD_FALLBACK=true&#10;    fi&#10;&#10;    if [ &quot;$BUILD_FALLBACK&quot; = true ]; then&#10;        # Build the php image directly and then bring up the stack without building&#10;        PHP_IMAGE_TAG=&quot;${PROJECT_NAME}_php&quot;&#10;        log_step &quot;Construindo imagem php diretamente: ${PHP_IMAGE_TAG}&quot;&#10;        if docker build -t &quot;${PHP_IMAGE_TAG}&quot; ./.docker/php; then&#10;            log_success &quot;Imagem php construída: ${PHP_IMAGE_TAG}&quot;&#10;        else&#10;            log_error &quot;Falha ao construir a imagem php diretamente&quot;&#10;            popd &gt;/dev/null&#10;            exit 1&#10;        fi&#10;&#10;        log_step &quot;Iniciando containers (sem rebuild)...&quot;&#10;        docker-compose up -d --no-build&#10;    else&#10;        log_step &quot;Iniciando containers...&quot;&#10;        docker-compose up -d&#10;    fi&#10;&#10;    # Wait for containers to be ready&#10;    log_step &quot;Aguardando containers iniciarem...&quot;&#10;    local max_attempts=30&#10;    local attempt=0&#10;    while ! docker-compose ps app | grep -q &quot;Up&quot; &amp;&amp; [ $attempt -lt $max_attempts ]; do&#10;        echo -n &quot;.&quot;&#10;        sleep 2&#10;        attempt=$((attempt + 1))&#10;    done&#10;    echo &quot;&quot;&#10;&#10;    if [ $attempt -eq $max_attempts ]; then&#10;        log_error &quot;Timeout aguardando containers iniciarem&quot;&#10;        docker-compose logs app || true&#10;        popd &gt;/dev/null&#10;        exit 1&#10;    fi&#10;&#10;    # Wait for postgres to be healthy&#10;    log_step &quot;Aguardando banco de dados...&quot;&#10;    attempt=0&#10;    while ! docker-compose exec -T postgres pg_isready -U user -d &quot;${PROJECT_NAME}_db&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; [ $attempt -lt $max_attempts ]; do&#10;        echo -n &quot;.&quot;&#10;        sleep 2&#10;        attempt=$((attempt + 1))&#10;    done&#10;    echo &quot;&quot;&#10;&#10;    if [ $attempt -eq $max_attempts ]; then&#10;        log_error &quot;Timeout aguardando banco de dados&quot;&#10;        docker-compose logs postgres || true&#10;        popd &gt;/dev/null&#10;        exit 1&#10;    fi&#10;&#10;    # Give extra time for services to fully initialize&#10;    sleep 5&#10;    increment_progress&#10;    popd &gt;/dev/null&#10;}&#10;&#10;create_framework() {&#10;    # Build framework inside the project dir but don't leave the script inside it&#10;    pushd &quot;$PROJECT_DIR&quot; &gt;/dev/null || { log_error &quot;Não foi possível entrar em $PROJECT_DIR&quot;; exit 1; }&#10;    TMP_FRAMEWORK=&quot;.canvas_tmp_framework&quot;&#10;    mkdir -p &quot;$TMP_FRAMEWORK&quot;&#10;&#10;    log_step &quot;Criando framework $FRAMEWORK...&quot;&#10;    if [ &quot;$FRAMEWORK&quot; = &quot;Laravel&quot; ]; then&#10;        # 1️⃣ Criar Laravel na pasta temporária&#10;        docker run --rm -v &quot;$(pwd)/$TMP_FRAMEWORK&quot;:/var/www/html -w /var/www/html composer create-project laravel/laravel . --no-interaction&#10;&#10;        # 2️⃣ Instalar Octane + Swoole **antes do merge**&#10;        docker run --rm -v &quot;$(pwd)/$TMP_FRAMEWORK&quot;:/var/www/html -w /var/www/html composer require laravel/octane --no-interaction&#10;    else&#10;        # Hyperf&#10;        docker build -t canvas-php-hyperf-temp -f .docker/php/Dockerfile-hyperf .&#10;        docker run --rm -v &quot;$(pwd)/$TMP_FRAMEWORK&quot;:/var/www/html -w /var/www/html canvas-php-hyperf-temp composer create-project hyperf/hyperf-skeleton . --no-interaction&#10;    fi&#10;    increment_progress&#10;&#10;    # 3️⃣ Remover diretórios antigos do host&#10;    dirs_to_remove=(app bootstrap config database public resources routes storage tests vendor)&#10;    for dir in &quot;${dirs_to_remove[@]}&quot;; do [ -d &quot;$dir&quot; ] &amp;&amp; rm -rf &quot;$dir&quot;; done&#10;&#10;    # 4️⃣ Mover framework para pasta do host&#10;    shopt -s dotglob&#10;    mv &quot;$TMP_FRAMEWORK&quot;/* .&#10;    rm -rf &quot;$TMP_FRAMEWORK&quot;&#10;    shopt -u dotglob&#10;    increment_progress&#10;    log_success &quot;Framework movido e merge concluído&quot;&#10;    popd &gt;/dev/null&#10;}&#10;&#10;# New function: update the project's .env so containerized services are referenced correctly.&#10;update_project_env() {&#10;    local env_file=&quot;${PROJECT_DIR}/.env&quot;&#10;&#10;    # Ensure project directory exists and env path is writable&#10;    mkdir -p &quot;$(dirname &quot;$env_file&quot;)&quot;&#10;&#10;    # If no .env exists, create an empty one so we can write into it&#10;    if [ ! -f &quot;$env_file&quot; ]; then&#10;        touch &quot;$env_file&quot;&#10;    fi&#10;&#10;    # Helper to set or add a KEY=VALUE line in the env file (portable with sed -i.bak)&#10;    update_kv() {&#10;        local kv=&quot;$1&quot;&#10;        local key=&quot;${kv%%=*}&quot;&#10;        local val=&quot;${kv#*=}&quot;&#10;        if grep -qE &quot;^${key}=&quot; &quot;$env_file&quot;; then&#10;            sed -i.bak &quot;s|^${key}=.*|${key}=${val}|&quot; &quot;$env_file&quot;&#10;        else&#10;            # Append at end&#10;            printf &quot;%s=%s\n&quot; &quot;$key&quot; &quot;$val&quot; &gt;&gt; &quot;$env_file&quot;&#10;        fi&#10;    }&#10;&#10;    log_step &quot;Atualizando $env_file com valores de container...&quot;&#10;&#10;    # Desired values for containerized environment&#10;    update_kv &quot;APP_NAME=${PROJECT_NAME}&quot;&#10;    update_kv &quot;APP_ENV=local&quot;&#10;    update_kv &quot;APP_DEBUG=true&quot;&#10;    update_kv &quot;APP_URL=http://localhost:8080&quot;&#10;&#10;    update_kv &quot;DB_CONNECTION=pgsql&quot;&#10;    update_kv &quot;DB_HOST=postgres&quot;&#10;    update_kv &quot;DB_PORT=5432&quot;&#10;    update_kv &quot;DB_DATABASE=${PROJECT_NAME}_db&quot;&#10;    update_kv &quot;DB_USERNAME=user&quot;&#10;    update_kv &quot;DB_PASSWORD=secret&quot;&#10;&#10;    update_kv &quot;BROADCAST_DRIVER=log&quot;&#10;    update_kv &quot;CACHE_DRIVER=file&quot;&#10;    update_kv &quot;QUEUE_CONNECTION=redis&quot;&#10;    update_kv &quot;SESSION_DRIVER=file&quot;&#10;&#10;    update_kv &quot;REDIS_HOST=redis&quot;&#10;    update_kv &quot;REDIS_PASSWORD=null&quot;&#10;    update_kv &quot;REDIS_PORT=6379&quot;&#10;&#10;    # Minio / S3 settings (use minio container as S3-compatible endpoint)&#10;    update_kv &quot;FILESYSTEM_DRIVER=s3&quot;&#10;    update_kv &quot;AWS_ACCESS_KEY_ID=minioadmin&quot;&#10;    update_kv &quot;AWS_SECRET_ACCESS_KEY=minioadmin&quot;&#10;    update_kv &quot;AWS_DEFAULT_REGION=us-east-1&quot;&#10;    update_kv &quot;AWS_BUCKET=${PROJECT_NAME}-bucket&quot;&#10;    update_kv &quot;AWS_ENDPOINT=http://minio:9000&quot;&#10;    update_kv &quot;AWS_USE_PATH_STYLE_ENDPOINT=true&quot;&#10;&#10;    # Mailpit (local SMTP) settings&#10;    update_kv &quot;MAIL_MAILER=smtp&quot;&#10;    update_kv &quot;MAIL_HOST=mailpit&quot;&#10;    update_kv &quot;MAIL_PORT=1025&quot;&#10;    update_kv &quot;MAIL_USERNAME=&quot;&#10;    update_kv &quot;MAIL_PASSWORD=&quot;&#10;    update_kv &quot;MAIL_ENCRYPTION=&quot;&#10;    update_kv &quot;MAIL_FROM_ADDRESS=hello@${PROJECT_NAME}.local&quot;&#10;    update_kv &quot;MAIL_FROM_NAME=${PROJECT_NAME}&quot;&#10;&#10;    # Remove sed backup if created&#10;    rm -f &quot;${env_file}.bak&quot; 2&gt;/dev/null || true&#10;&#10;    increment_progress&#10;    log_success &quot;$env_file atualizado&quot;&#10;}&#10;&#10;setup_laravel() {&#10;    if [ &quot;$FRAMEWORK&quot; = &quot;laravel&quot; ]; then&#10;        # Run all docker-compose commands inside the project directory&#10;        pushd &quot;$PROJECT_DIR&quot; &gt;/dev/null || { log_error &quot;Não foi possível entrar em $PROJECT_DIR&quot;; return 1; }&#10;&#10;        log_step &quot;Configurando Laravel Octane...&quot;&#10;&#10;        # Fix permissions&#10;        docker-compose exec -T app chown -R www-data:www-data /var/www/html/storage /var/www/html/bootstrap/cache&#10;        docker-compose exec -T app chmod -R 775 /var/www/html/storage /var/www/html/bootstrap/cache&#10;&#10;        # Generate application key&#10;        docker-compose exec -T app php artisan key:generate || true&#10;&#10;        # Install and configure Octane&#10;        docker-compose exec -T app composer require laravel/octane || true&#10;        docker-compose exec -T app php artisan octane:install --server=swoole --no-interaction || true&#10;&#10;        # Run Laravel optimizations&#10;        docker-compose exec -T app php artisan config:cache || true&#10;        docker-compose exec -T app php artisan route:cache || true&#10;        docker-compose exec -T app php artisan view:cache || true&#10;&#10;        # Restart the container to apply Octane&#10;        docker-compose restart app || true&#10;&#10;        increment_progress&#10;        log_success &quot;Laravel Octane + Swoole configurado com sucesso&quot;&#10;&#10;        popd &gt;/dev/null&#10;    fi&#10;}&#10;&#10;main() {&#10;    check_dependencies&#10;&#10;    # Non-interactive support for CI or automated runs&#10;    if [ -n &quot;${CI_PROJECT_NAME:-}&quot; ] &amp;&amp; [ -n &quot;${CI_FRAMEWORK:-}&quot; ]; then&#10;        PROJECT_NAME=&quot;${CI_PROJECT_NAME}&quot;&#10;        FRAMEWORK=&quot;${CI_FRAMEWORK}&quot;&#10;        echo &quot;Non-interactive mode: PROJECT_NAME=$PROJECT_NAME, FRAMEWORK=$FRAMEWORK&quot;&#10;        increment_progress&#10;    else&#10;        select_framework&#10;    fi&#10;&#10;    # Absolute project path (use cwd as base) so functions can operate even when cwd changes&#10;    PROJECT_DIR=&quot;$(pwd)/$PROJECT_NAME&quot;&#10;&#10;    create_essential_files&#10;    create_framework&#10;    update_project_env&#10;    initialize_containers&#10;    setup_laravel&#10;&#10;    PROGRESS_CURRENT=$PROGRESS_TOTAL&#10;    show_progress; echo&#10;    log_success &quot;Projeto $PROJECT_NAME criado com sucesso com o framework $FRAMEWORK!&quot;&#10;    echo &quot; Pasta do projeto: $(pwd)&quot;&#10;    echo &quot; App: http://localhost:8080&quot;&#10;    echo &quot; Postgres: localhost:5432 (db:${PROJECT_NAME}_db / user:user / pass:secret)&quot;&#10;    echo &quot; Redis: localhost:6379&quot;&#10;}&#10;&#10;main" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>